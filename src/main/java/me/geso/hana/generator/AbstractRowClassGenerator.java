package me.geso.hana.generator;

import java.sql.SQLException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.slf4j.LoggerFactory;

import me.geso.dbinspector.Column;
import me.geso.dbinspector.ExportedKey;
import me.geso.dbinspector.ImportedKey;
import me.geso.dbinspector.PrimaryKey;
import me.geso.dbinspector.Table;

// TODO generate toString method.
class AbstractRowClassGenerator extends Renderer {

	private final List<ColumnHook> columnHooks = new ArrayList<ColumnHook>();
	private final List<TableHook> beforeInsertHooks = new ArrayList<TableHook>();
	private final List<TableHook> beforeUpdateHooks = new ArrayList<TableHook>();
	private final Table table;
	private final Configuration configuration;

	public AbstractRowClassGenerator(Table table, Configuration configuration) {
		this.table = table;
		this.configuration = configuration;
	}

	// String baseClass, String packageName, String className
	public String render() throws SQLException {
		if (table == null) {
			throw new IllegalArgumentException("Table object must not be null");
		}

		appendf("package %s;\n",
				configuration.generateAbstractPackageName());
		append("\n");
		append("import java.sql.PreparedStatement;\n");
		append("import java.sql.ResultSet;\n");
		append("import java.sql.ResultSetMetaData;\n");
		append("import java.sql.SQLException;\n");
		append("import java.sql.Blob;\n");
		append("import java.util.List;\n");
		append("import java.util.Arrays;\n");
		append("import java.util.Optional;\n");
		append("import java.time.Instant;\n");
		append("import javax.annotation.Generated;\n");
		append("import org.slf4j.Logger;\n");
		append("import org.slf4j.LoggerFactory;\n");
		append("\n");
		append("import me.geso.hana.HanaSession;\n");
		append("import me.geso.hana.annotation.Table;\n");
		append("import me.geso.hana.InsertStatement;\n");
		append("import me.geso.hana.HanaException;\n");
		append("\n");

		appendf("@Generated(value={}, comments=\"Generated by me.geso.hana.generator.RowClassGenerator\", date=\"%s\")\n",
				Instant.now());
		appendf("@SuppressWarnings(\"unused\")\n");
		appendf("@Table(name = \"%s\")\n", table.getName());
		appendf("public abstract class %s extends %s {\n",
				configuration.generateAbstractClassName(table.getName()),
				configuration.generateBaseClass(table.getName()));
		appendf("	static final Logger logger = LoggerFactory.getLogger(%s.class);",
				configuration.generateAbstractClassName(table.getName()));

		renderGetTableName(table);
		renderGetPrimaryKeys(table);
		renderInitialize(table);
		renderInsert(table);
		renderGetColumn(table);
		renderFind(table);
		renderRefetch(table);
		renderToString(table);

		for (Column column : table.getColumns()) {
			renderColumn(
					configuration.generateConcreteClassName(table.getName()),
					column);
		}
		table.getExportedKeys().stream().forEach(e -> {
			renderHasManyCount(e); // countJobs
			renderHasManySearchChildren(e); // searchJobs
		});
		table.getImportedKeys().stream().forEach(e -> {
			renderHasARetrieve(e); // retrieveRepository
		});
		append("}\n");
		return this.toString();
	}

	private void renderToString(Table table) throws SQLException {
		appendf("       @Override\n");
		appendf("	public String toString() {\n");
		appendf("		return \"%s [\"\n",
				configuration.generateAbstractClassName(table.getName()));
		for (Column column : table.getColumns()) {
			appendf("			+ \" %s=\" + %s\n", column.getName(), column.getName());
		}
		appendf("		+ \"]\";\n");
		appendf("	}\n");
	}

	private void renderHasManySearchChildren(ExportedKey e) {
		appendf("	public List<%s> %s() throws SQLException, HanaException {\n",
				configuration.generateConcreteFullClassName(e
						.getForeignKeyTable()),
				configuration.generateSearchChildrenMethodName(e
						.getForeignKeyTable()));
		appendf("		return this.currentSession().search(%s.class).where(\"%s=?\", this.%s).getResultList();\n",
				configuration.generateConcreteFullClassName(e
						.getForeignKeyTable()),
				e.getForeignKeyColumn(),
				e.getPrimaryKeyColumn());
		appendf("	}\n");
		appendf("	\n");
	}

	private void renderHasManyCount(ExportedKey e) {
		String concreteForeignClass = configuration
				.generateConcreteFullClassName(e
						.getForeignKeyTable());
		appendf("	/**\n");
		appendf("	 * Seach %s related on %s.\n", e.getForeignKeyTable(),
				e.getPrimaryKeyTable());
		appendf("	 */\n");
		appendf("	public long %s() throws SQLException, HanaException {\n",
				configuration.generateCountMethodName(e.getForeignKeyTable()));
		appendf("		return this.currentSession().search(%s.class).where(\"%s=?\", this.%s).count();\n",
				concreteForeignClass, e.getForeignKeyColumn(),
				e.getPrimaryKeyColumn());
		appendf("	}\n");
		appendf("	\n");
	}

	private void renderHasARetrieve(ImportedKey e) {
		appendf("	public Optional<%s> %s() throws SQLException, HanaException {\n",
				configuration.generateConcreteFullClassName(e
						.getPrimaryKeyTable()),
				configuration
				.generateRetrieveMethodName(e.getPrimaryKeyTable()));
		appendf("		return this.currentSession().search(%s.class).where(\"%s=?\", this.%s).first();\n",
				configuration.generateConcreteFullClassName(e
						.getPrimaryKeyTable()),
				e.getPrimaryKeyColumn(),
				e.getForeignKeyColumn());
		appendf("	}\n");
		appendf("	\n");
	}

	private void renderRefetch(Table table) throws SQLException {
		String concreteClass = configuration
				.generateConcreteFullClassName(table.getName());
		appendf("	public Optional<%s> refetch() throws SQLException, HanaException {\n",
				concreteClass);
		appendf("		return this.find(");
		List<PrimaryKey> primaryKeys = table.getPrimaryKeys();
		for (int i = 0; i < primaryKeys.size(); ++i) {
			appendf("%s", primaryKeys.get(i).getColumnName());
			if (i != primaryKeys.size() - 1) {
				appendf(", ");
			}
		}
		append(");\n");
		append("	}\n");
		append("\n");
	}

	private void renderFind(Table table) throws SQLException {
		String concreteClass = configuration
				.generateConcreteFullClassName(table.getName());
		appendf("	public Optional<%s> find(", concreteClass);
		List<PrimaryKey> primaryKeys = table.getPrimaryKeys();
		for (int i = 0; i < primaryKeys.size(); ++i) {
			PrimaryKey pk = primaryKeys.get(i);
			appendf("%s %s", configuration.getJavaTypeName(pk.getDataType()),
					pk.getColumnName());
			if (i != primaryKeys.size() - 1) {
				appendf(", ");
			}
		}
		append(") throws SQLException, HanaException {\n");
		appendf("		return currentSession().search(%s.class)\n", concreteClass);
		for (PrimaryKey pk : table.getPrimaryKeys()) {
			appendf("		.where(\"%s=?\", %s)\n",
					pk.getColumnName(),
					pk.getColumnName());
		}
		append("		.first();\n");
		append("	}\n");
		append("\n");
	}

	private void renderGetColumn(Table table) throws SQLException {
		append("	@Override\n");
		append("	public String getColumn(String column) throws SQLException {\n");
		append("		switch (column) {\n");
		table.getColumns()
				.stream()
				.forEach(
						column -> {
							appendf("			case \"%s\":\n", column.getName());
							appendf("				return String.valueOf(this.%s);\n",
									column.getName());
						});
		appendf("			default:\n");
		appendf("				return this.getExtraColumn(column);\n");
		append("		}\n");
		append("	}\n");
		append("\n\n");
	}

	public void renderInitialize(Table table) throws SQLException {
		append("	@Override\n");
		append("	public void initialize(ResultSet rs) throws SQLException {\n");
		append("		ResultSetMetaData meta = rs.getMetaData();\n");
		append("		int columnCount = meta.getColumnCount();\n");
		append("		for (int i=1; i<columnCount+1; ++i) {\n");
		append("			String label = meta.getColumnLabel(i);\n");
		append("			switch (label) {\n");
		table.getColumns()
				.stream()
				.forEach(
						column -> {
							appendf("			case \"%s\":\n", column.getName());
							appendf("				this.%s = %s;\n",
									column.getName(),
									configuration.getResultSetMethod(column
											.getDataType()));
							appendf("				break;\n");
						});
		append("			default:\n");
		append("				this.setExtraColumn(label, rs.getString(i));\n");
		append("			} // switch\n");
		append("		} // for\n");
		append("	}\n");
	}

	private void renderColumn(String klass, Column column) {
		String concreteClass = configuration
				.generateConcreteFullClassName(table.getName());

		String javaType = configuration.getJavaTypeName(column.getDataType());
		appendf("	// Column: %s %s(%s)\n",
				column.getName(), column.getTypeName(),
				column.getSize());
		// field
		appendf("	private %s %s",
				javaType, column.getName());
		String defaultValue = getDefaultValue(column);
		if (defaultValue != null) {
			appendf("=%s", defaultValue);
		}
		append(";\n\n");

		// getter
		appendf("	public %s %s() {\n",
				javaType, configuration.generateGetterName(column.getName()));
		appendf("		return this.%s;\n",
				column.getName());
		append("	}\n\n");

		// setter
		appendf("	public %s %s(%s value) {\n",
				concreteClass,
				configuration.generateSetterName(column.getName()), javaType);
		appendf("		this.%s = value;\n",
				column.getName());
		appendf("		this.dirtyColumns.add(\"%s\");\n", column.getName());
		appendf("		return (%s)this;\n", concreteClass);
		append("	}\n");
		append("\n");

		this.columnHooks.stream().forEach(hook -> {
			hook.run(this, column);
		});
	}

	private String getDefaultValue(Column column) {
		if (column.getName().equals("created_on")) {
			return "Instant.now().getEpochSecond()";
		} else {
			return null;
		}
	}

	public void addColumnHook(ColumnHook hook) {
		this.columnHooks.add(hook);
	}

	public void addBeforeInsertHook(TableHook hook) {
		this.beforeInsertHooks.add(hook);
	}

	public void addBeforeUpdateHook(TableHook hook) {
		this.beforeUpdateHooks.add(hook);
	}

	@FunctionalInterface
	public static interface ColumnHook {

		public void run(AbstractRowClassGenerator generator, Column column);
	}

	@FunctionalInterface
	public static interface TableHook {

		public void run(Table table);
	}

	// getTableName
	private void renderGetTableName(Table table) {
		appendf("	public String getTableName() { return \"%s\"; }\n",
				table.getName());
	}

	// getPrimaryKeys()
	private void renderGetPrimaryKeys(Table table) throws SQLException {
		appendf("	private static List<String> primaryKeys = Arrays.asList(");
		List<PrimaryKey> primaryKeys = table.getPrimaryKeys();
		for (int i = 0; i < primaryKeys.size(); ++i) {
			appendf("\"%s\"", primaryKeys.get(i).getColumnName());
			if (i != primaryKeys.size() - 1) {
				append(",");
			}
		}
		appendf(");\n");
		appendf("	@Override\n");
		appendf("	public List<String> getPrimaryKeys() {\n");
		appendf("		return primaryKeys;\n");
		append("	}\n\n");
	}

	private void renderInsert(Table table) throws SQLException {
		append("	@Override\n");
		append("	public void insert(HanaSession hanaSession) throws SQLException, HanaException {\n");
		this.beforeInsertHooks.stream().forEach(code -> {
			code.run(table);
		});
		append("		InsertStatement insert = new InsertStatement(hanaSession, this.getTableName());\n");
		append("		for (String col: dirtyColumns) {\n");
		append("			switch (col) {\n");
		for (Column column : table.getColumns()) {
			appendf("			case \"%s\":\n", column.getName());
			appendf("				insert.value(col, this.%s());\n",
					configuration.generateGetterName(column.getName()));
			appendf("				break;\n");
		}
		append("			}\n");
		append("		}\n");

		// fill auto increment value to row object.
		Optional<Column> ai = table.getColumns().stream().filter(column -> {
			return column.isAutoIncrement();
		}).findFirst();
		if (ai.isPresent()) {
			appendf("		PreparedStatement stmt = insert.buildStatement();\n");
			appendf("		this.session.logStatement(stmt);\n");
			appendf("		stmt.execute();\n");
			appendf("		try (ResultSet rs = stmt.getGeneratedKeys();) {\n");
			appendf("			if (rs.next()) {\n");
			appendf("				this.%s(rs.getInt(1));\n", configuration.generateSetterName(ai.get().getName()));
			appendf("			}\n");
			appendf("		}\n");
		} else {
			appendf("		PreparedStatement stmt = insert.buildStatement();\n");
			appendf("		this.session.logStatement(stmt);\n");
			appendf("		stmt.executeUpdate();\n");
		}
		append("		columns.addAll(dirtyColumns);\n");
		append("		dirtyColumns.clear();\n");
		append("		this.session = hanaSession;\n");
		append("	}\n\n");
	}

}
