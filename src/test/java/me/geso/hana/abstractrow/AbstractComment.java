package me.geso.hana.abstractrow;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Blob;
import java.util.List;
import java.util.Arrays;
import java.util.stream.Stream;
import java.util.Optional;
import java.time.Instant;
import javax.annotation.Generated;

import me.geso.hana.annotation.Table;
import me.geso.hana.Insert;
import me.geso.hana.Criteria;
import me.geso.hana.HanaException;
import me.geso.hana.Select;

@Generated(value={}, comments="Generated by me.geso.hana.generator.RowClassGenerator")
@SuppressWarnings("unused")
@Table(name = "comment")
public abstract class AbstractComment extends me.geso.hana.AbstractRow {
	public String getTableName() { return "comment"; }
	private static final List<String> primaryKeys = Arrays.asList("id");
	@Override
	public List<String> getPrimaryKeys() {
		return primaryKeys;
	}

	@Override
	public void initialize(ResultSet rs) throws SQLException {
		ResultSetMetaData meta = rs.getMetaData();
		int columnCount = meta.getColumnCount();
		for (int i=1; i<columnCount+1; ++i) {
			String label = meta.getColumnLabel(i);
			switch (label) {
			case "id":
				this.id = rs.getLong(i);
				this._HaNa_selected_id = true;
				break;
			case "entry_id":
				this.entry_id = rs.getLong(i);
				this._HaNa_selected_entry_id = true;
				break;
			case "body":
				this.body = rs.getString(i);
				this._HaNa_selected_body = true;
				break;
			case "data":
				this.data = rs.getBlob(i+1);
				this._HaNa_selected_data = true;
				break;
			case "created_on":
				this.created_on = rs.getLong(i);
				this._HaNa_selected_created_on = true;
				break;
			} // switch
		} // for
	}
	public me.geso.hana.row.Comment insert(Connection connection) throws SQLException, HanaException {
		Insert insert = Insert.into(this.getTableName());
		if (_HaNa_dirty_id) {
			insert.value("id", this.getId());
		}
		if (_HaNa_dirty_entry_id) {
			insert.value("entry_id", this.getEntryId());
		}
		if (_HaNa_dirty_body) {
			insert.value("body", this.getBody());
		}
		if (_HaNa_dirty_data) {
			insert.value("data", this.getData());
		}
		if (_HaNa_dirty_created_on) {
			insert.value("created_on", this.getCreatedOn());
		}
		PreparedStatement stmt = insert.build(connection).prepare(connection);
		stmt.execute();
		try (ResultSet rs = stmt.getGeneratedKeys();) {
			if (rs.next()) {
				this.setId(rs.getLong(1));
				this._HaNa_selected_id = true;
			}
		}
		return (me.geso.hana.row.Comment)this;
	}

	public static Optional<me.geso.hana.row.Comment> find(Connection connection, long id) throws SQLException, HanaException {
		return Select.from(me.geso.hana.row.Comment.class)
		.where(me.geso.hana.Condition.eq("id", id))
		.stream(connection).findFirst();
	}

	public Optional<me.geso.hana.row.Comment> refetch(Connection connection) throws SQLException, HanaException {
		return AbstractComment.find(connection,id);
	}

	public static long count(Connection connection) throws SQLException, HanaException {
		return Select.from(AbstractComment.class).count(connection)
;	}
	@Override
	public Criteria criteria() throws SQLException, HanaException {
		if (!this._HaNa_selected_id) {
				throw new HanaException("The row doesn't contain *selected* primary key: id");
		}

		Criteria criteria = null;
		criteria = me.geso.hana.Condition.and(criteria, me.geso.hana.Condition.eq("id", this.getId()));
		return criteria;
	}
	@Override
	protected void setUpdateParameters(me.geso.hana.Update update) throws HanaException, SQLException {
		if (_HaNa_dirty_id) {
			update.set("id", this.getId());
		}
		if (_HaNa_dirty_entry_id) {
			update.set("entry_id", this.getEntryId());
		}
		if (_HaNa_dirty_body) {
			update.set("body", this.getBody());
		}
		if (_HaNa_dirty_data) {
			update.set("data", this.getData());
		}
		if (_HaNa_dirty_created_on) {
			update.set("created_on", this.getCreatedOn());
		}
	}
       @Override
	public String toString() {
		return "AbstractComment ["
			+ " id=" + id
			+ " entry_id=" + entry_id
			+ " body=" + body
			+ " data=" + data
			+ " created_on=" + created_on
		+ "]";
	}
	// Column: id INTEGER(10)
	private long id;

	private boolean _HaNa_dirty_id;	private boolean _HaNa_selected_id;	public long getId() {
		return this.id;
	}

	public me.geso.hana.row.Comment setId(long value) {
		this.id = value;
		_HaNa_dirty_id = true;
		return (me.geso.hana.row.Comment)this;
	}

	// Column: entry_id INTEGER(10)
	private long entry_id;

	private boolean _HaNa_dirty_entry_id;	private boolean _HaNa_selected_entry_id;	public long getEntryId() {
		return this.entry_id;
	}

	public me.geso.hana.row.Comment setEntryId(long value) {
		this.entry_id = value;
		_HaNa_dirty_entry_id = true;
		return (me.geso.hana.row.Comment)this;
	}

	// Column: body VARCHAR(255)
	private String body;

	private boolean _HaNa_dirty_body;	private boolean _HaNa_selected_body;	public String getBody() {
		return this.body;
	}

	public me.geso.hana.row.Comment setBody(String value) {
		this.body = value;
		_HaNa_dirty_body = true;
		return (me.geso.hana.row.Comment)this;
	}

	// Column: data BLOB(2147483647)
	private Blob data;

	private boolean _HaNa_dirty_data;	private boolean _HaNa_selected_data;	public Blob getData() {
		return this.data;
	}

	public me.geso.hana.row.Comment setData(Blob value) {
		this.data = value;
		_HaNa_dirty_data = true;
		return (me.geso.hana.row.Comment)this;
	}

	// Column: created_on INTEGER(10)
	private long created_on=Instant.now().getEpochSecond();

	private boolean _HaNa_dirty_created_on;	private boolean _HaNa_selected_created_on;	public long getCreatedOn() {
		return this.created_on;
	}

	public me.geso.hana.row.Comment setCreatedOn(long value) {
		this.created_on = value;
		_HaNa_dirty_created_on = true;
		return (me.geso.hana.row.Comment)this;
	}

	public Optional<me.geso.hana.row.Entry> retrieveEntry(Connection connection) throws SQLException, HanaException {
		return Select.from(me.geso.hana.row.Entry.class).where(me.geso.hana.Condition.eq("id", this.entry_id)).stream(connection).findFirst();
	}
	
}
